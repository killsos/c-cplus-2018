## 指针 内存

- 内存地址

		
		将内存抽象成一个很大的一维字符数组。
		
		编码就是对内存的每一个字节分配一个 32 位或 64 位的编号(与 32 位或者
		64 位处理器相关)。
		
		这个内存编号我们称之为内存地址
		
		内存中的每一个数据都会分配相应的地址: 
			
			char:占一个字节分配一个地址
			
			int: 占四个字节分配四个地址
			
			float、struct、函数、数组等
		
	
- 指针和指针变量

		
		 内存区的每一个字节都有一个编号，这就是“地址”。
		
		 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给
			这个变量分配内存单元，并确定它的内存地址(编号)
		
		指针的实质就是内存“地址”。指针就是地址，地址就是指针。
		
		指针是内存单元的编号，指针变量是存放地址的变量。
		
		通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样
		
		

- 指针变量的定义和使用

			
		指针也是一种数据类型，指针变量也是一种变量 
		
		指针变量指向谁，就把谁的地址赋值给指针变量 
		
		“*”操作符操作的是指针变量指向的内存空间	
			
		注意:&可以取得一个变量在内存中的地址。
		
		但是，不能取寄存器变量，因为 寄存器变量不在内存里，
		
		而在 CPU 里面，所以是没有地址的。	
			
	
- 通过指针间接修改变量的值

		
		int a = 0; 
		
		int b = 11; 
		
		int *p = &a;
		*p = 100;
		
		printf("a = %d, *p = %d\n", a, *p);
		
		p = &b;
		
		*p = 22;
		
		printf("b = %d, *p = %d\n", b, *p);
		
		
		

- 指针大小

		
		使用 sizeof()测量指针的大小，得到的总是:4 或 8 
		
		sizeof()测的是指针变量指向存储地址的大小
		
		在 32 位平台，所有的指针(地址)都是 32 位(4 字节) 
		
		在 64 位平台，所有的指针(地址)都是 64 位(8 字节)
		
		
	
- 野指针和空指针

		
		指针变量也是变量，是变量就可以任意赋值，不要越界即可(32 位为 4 字节， 
		
		64 位为 8 字节)，但是，任意数值赋值给指针变量没有意义，因为这样的指针 
		
		就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的 内存区域)。
		
		所以，野指针不会直接引发错误，操作野指针指向的内存区域才 会出问题。
		
		int a = 100;
		int *p;
		
		p = a; //把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义
		
		p = 0x12345678; //给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义 
		
		*p = 1000; //操作野指针指向未知区域，内存出问题，err
		
		但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向 
		
		任何变量(空闲可用)，C 语言中，可以把 NULL 赋值给此指针，
		
		这样就标志此指 针为空指针，没有任何指针。
		
		NULL 是一个值为 0 的宏常量:
		
			int *p = NULL;
		
		#define NULL ((void *)0)
		
		

- 万能指针 void *

		
		void *指针可以指向任意变量的内存空间:
		
		void *p = NULL; 
		
		int a = 10;
		
		p = (void *)&a; //指向变量时，最好转换为void *
		
		//使用指针变量指向的内存时，转换为int *
		
		*( (int *)p ) = 11;
		
		printf("a = %d\n", a);
		
		

- const 修饰的指针变量

			
		int a = 100; int b = 200;
		
		//指向常量的指针 //修饰*，指针指向内存区域不能修改，
		
		指针指向可以变 const int *p1 = &a; 
		
		//等价于int const *p1 = &a;
		
		//*p1 = 111; //err
		p1 = &b; //ok
		
		//指针常量 
		//修饰p1，指针指向不能变，指针指向的内存可以修改 int * const p2 = &a;
		
		//p2 = &b; //err
		
		*p2 = 222; //ok	
			
			
	
- 指针和数组

		
		数组名
		
		数组名字是数组的首元素地址，但它是一个常量
		
		int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; 
		
		printf("a = %p\n", a); 
		
		printf("&a[0] = %p\n", &a[0]);
		
		//a = 10; //err, 数组名只是常量，不能修改
		

- 指针加减运算

			
		加法运算
		
			指针计算不是简单的整数相加
			
				如果是一个 int *，+1 的结果是增加一个 int 的大小 
				
				如果是一个 char *，+1 的结果是增加一个 char 大小
			
		减法运算
		
			
			

- 指针数组

			
		指针数组，它是数组，数组的每个元素都是指针类型
		
		//指针数组 
		
		int *p[3]	
			
			
	
- 多级指针

		
		C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级 指针。
		
		二级指针就是指向一个一级指针变量地址的指针。 
		
		三级指针基本用不着，但考试会考
		
		int a = 10;
		int *p = &a; //一级指针
		*p = 100; 	//*p就是a
		
		int **q = &p; //*q就是p  //**q就是a
		
		int ***t = &q; //*t就是q //**t就是p //***t就是a
		
	
- 指针和函数

		
		函数形参改变实参的值
		
		数组名做函数参数
			
			数组名做函数参数，函数的形参会退化为指针
		
		指针做为函数的返回值
		
		

- 指针和字符串

			
		指针和字符串
		
			char str[] = "hello world"; 
		
			char *p = str;	
			
		字符指针做函数参数
		
		
		const 修饰的指针变量
		
		//const修饰一个变量为只读 
		const int a = 10;
		//a = 100; //err
		
		//指针变量， 指针指向的内存， 2个不同概念 
		char buf[] = "aklgjdlsgjlkds";
		
		//从左往右看，跳过类型，看修饰哪个字符
		//如果是*， 说明指针指向的内存不能改变 
		
		//如果是指针变量，说明指针的指向不能改变，指针的值不能修改 
		
		const char *p = buf;
		
		// 等价于上面 char const *p1 = buf;
		
		//p[1] = '2'; //err
		
		p = "agdlsjaglkdsajgl"; //ok
		
		char * const p2 = buf; p2[1] = '3';
		
		//p2 = "salkjgldsjaglk"; //err
		
		//p3为只读，指向不能变，指向的内存也不能变 
		
		const char * const p3 = buf;
			
	
- 指针数组做为 main 函数的形参

		
		 int main(int argc, char *argv[]);
		 
		 main 函数是操作系统调用的，第一个参数标明 argc 数组的成员数量，
		 
		 argv 数组的每个成员都是 char *类型
		 
		 argv 是命令行参数的字符串数组
		 
		 argc 代表命令行参数的数量，程序名字本身算一个参数
		
	
- 指针小结

		
		int i				定义整形变量
		
		int *p				定义一个指向 int 的指针变量
		
		int a[10]			定义一个有 10 个元素的数组，每个元素类型为 int
		
		int *p[10]			定义一个有 10 个元素的数组，每个元素类型为 int*
		
		int func()			定义一个函数，返回值为 int 型
		
		int *func()			定义一个函数，返回值为 int *型
		
		int **p				定义一个指向 int 的指针的指针，二级指针
		   
		
		


## 内存管理

- 作用域

		
		C 语言变量的作用域分为:
			
			代码块作用域(代码块是{}之间的一段代码) 简称 块级作用域
			
			函数作用域
			
			文件作用域
		
		

- 局部变量
	
			
		局部变量也叫 auto 自动变量(auto 可写可不写)，
		一般情况下代码块{}内部定 义的变量都是自动变量，
		它有如下特点:
			
			在一个函数内定义，只在函数范围内有效
			
			在复合语句中定义，只在复合语句中有效
			
			随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束 
			
			如果没有赋初值，内容为随机	
			
			
	
-  静态(static)局部变量

		
		static 局部变量的作用域也是在定义的函数内有效
		
		static 局部变量的生命周期和程序运行周期一样
		
		同时staitc 局部变量的值只初始化一次，但可以赋值多次
		
		static 局部变量若未赋以初值，则由系统自动赋值:
		
			数值型变量自动赋初值 0
			
			字符型变量赋空字符
		

- 全局变量

		
		在函数外定义，可被本文件及其它文件中的函数所共用，
		
		若其它文件中的 函数调用此变量,须用 extern 声明
		
		全局变量的生命周期和程序运行周期一样
		
		不同文件的全局变量不可重名
		
		
		
	
- 静态(static)全局变量

				
		在函数外定义,作用范围被限制在所定义的文件中
			
		不同文件静态全局变量可以重名,但作用域不冲突
		
		static 全局变量的生命周期和程序运行周期一样
		
		同时 staitc 全局变量的值只初始化一次		
				
				

- extern 全局变量声明

		
		extern int a;声明一个变量，这个变量在别的文件中已经定义了，
		
		这里只是声明，而不是定义。
		
		
	
- 全局函数和静态函数

		
		在 C 语言中函数默认都是全局的，
		
		使用关键字 static 可以将函数声明为静态，
		
		函数定义为 static 就意味着这个函数只能在定义这个函数的文件中使用，
		
		在其他文件中不能调用，即使在其他文件中声明这个函数都没用。
		
		对于不同文件中的 staitc 函数名字可以相同。
		
		

- 总结

		
		类型					作用域			生命周期
		
		auto 变量			一对{}内			当前函数
		
		static 局部变量		一对{}内			整个程序运行期
		
		extern 变量			整个程序			整个程序运行期
		
		static 全局变量		当前文件			整个程序运行期
		
		extern	函数			整个程序			整个程序运行期
		
		static 函数 			当前文件 		整个程序运行期 
		
		register 变量 		一对{}内 		当前函数
		
		
		


- 内存分区

			
		C 代码经过预处理、编译、汇编、链接 4 步后生成一个可执行程序。
		
		在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况	
		
			file  filename
			
		程序没有加载到内存前，可 执行程序内部已经分好 3 段信息，分别为
		
			代码区(text)、数据区(data)和 未初始化数据区(bss)3 个部分
			
			(有些人直接把 data 和 bss 合起来叫做静态区或全局区)。
			
		1 代码区
		
			存放 CPU 执行的机器指令。通常代码区是可共享的(即另外的执行程序可以调用它)，
			
			使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一 份代码即可。
			
			代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。
			
			另外，代码区还规划了局部变量的相关信息
			
		2 全局初始化数据区/静态数据区(data 段)
		
			该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量(包括
			
			全局静态变量和局部静态变量)和常量数据(如字符串常量)。
		
		3 未初始化数据区(又叫 bss 区)
		
			存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程
			
			序开始执行之前被内核初始化为 0 或者空(NULL)
			
		ps:
				
			程序在加载到内存前，代码区和全局区(data 和 bss)的大小就是固定的，
			
			程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，
			
			除了根据可执行程序的信息分出代码区(text)、数据区(data)
			
			和未初始化数据区 (bss)之外，还额外增加了栈区、堆区。
			
		代码区(text segment) 
			
			加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是
			
			不可以在运行期间修改的。	
		
		未初始化数据区(BSS)
			
			加载的是可执行文件 BSS 段，位置可以分开亦可以紧靠数据段，
			
			存储于数据段的数据(全局未初始化，静态未初始化数据)
			
			的生存周期为整个程序运行过程。
		
		全局初始化数据区/静态数据区(data segment) 
		
			加载的是可执行文件数据段，存储于数据段(全局初始化，静态初始化数据，
			
			文字常量(只读))的数据的生存周期为整个程序运行过程。
		
		栈区(stack)
			
			栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、
			返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的
			生存周期为申请到释放该段栈空间。
		
		堆区(heap)
			
			堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。
			
			用于动态内存分配。堆在内存中位于 BSS 区和栈区之间。
			
			一般由程序员分配和释 放，若程序员不释放，程序结束时由操作系统回收。
		
		类型				作用域		生命周期			存储位置
		
		auto 变量		一对{}内		当前函数			栈区
		
		static 局部变量	一对{}内		整个程序运行期	初始化在 data 段，未初始化在 BSS 段
		
		extern 变量		整个程序		整个程序运行期	初始化在 data 段，未初始化在 BSS 段
		
		static 全局变量	当前文件		整个程序运行期	初始化在 data 段，未初始化在 BSS 段
		
		extern 函数		整个程序		整个程序运行期	代码区
		
		static 函数 		当前文件 	整个程序运行期	代码区
		
		register 变量 	一对{}内 	当前函数 		运行时存储在 CPU 寄存器
		
		字符串常量		当前文件 	整个程序运行期     data 段
		
		
		 
		
		
		
		

	