## c语言

- system函数

				
		#include <stdlib.h>
		int system(const char *command);
		
		功能:在已经运行的程序中执行另外一个外部程序
		
		参数:外部可执行程序名字
		
		返回值:
			
			成功:不同系统返回值不一样 
			
			失败:通常是 - 1		
						
				
	
- c程序编译步骤

		
		C 代码编译成可执行程序经过 4 步: 
		
		1)预处理:宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，
			这里并不会检查语法 
		
		2)编译:检查语法，将预处理后文件编译生成汇编文件
		
		3)汇编:将汇编文件生成目标文件(二进制文件)
		
		4)链接:C 语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接
			到最终的可执行程序中去
			
		
		-E 				只进行预处理
		
		-S(大写) 		只进行预处理和编译
			
		-c(小写) 		只进行预处理、编译和汇编
		
		-o file			指定生成的输出文件名为 file
		   
		
		预处理:	gcc -E hello.c -o hello.i 
		
		编 译:	gcc -S hello.i -o hello.s   // 生成汇编语言  这一步语法检查
		
		汇 编:	gcc -c hello.s -o hello.o   // 生成机器码
		
		链 接:	gcc -o hello_elf hello.o    // 链接库文件
		
		.c 		C 语言文件
		
		.i 		预处理后的 C 语言文件
		
		.s 		编译后的汇编文件
		
		.o		编译后的目标文件
		
		一步编译
		 
		 	gcc hello.c -o demo 
		
		

-  查找程序所依赖的动态库

			
		1)Linux 平台下，ldd(“l”为字母) 可执行程序 查看依赖的库
		
				ldd programName
				
				unix系统的静态库文件和动态库文件后缀分别是.a和.so
				
		2)Windows 平台下，需要相应软件(Depends.exe)
			
			windows静态库文件就是.lib文件，动态库文件就是.dll文件
		
		程序函数库可分为3种类型：
			
			静态函数库（static libraries）
			
			共享函数库（shared libraries）
			
			动态加载函数库（dynamically loaded libraries）
			
			1、静态函数库，是在程序执行前就加入到目标程序中去了
				
				.a 后缀名
			
			2、共享函数库，则是在程序启动的时候加载到程序中，它可以被不同的程序共享；
						动态加载函数库则可以在程序运行的任何时候动态的加载。
						
				.so
			
			3、动态函数库，并非另外一种库函数格式，区别是动态加载函数库是如何被程序员使用的。
		

- 寄存器名字

		
		8位				16 位			32 位			64 位
		
		A 				AX 				EAX 			RAX 
		
		B 				BX 				EBX 			RBX 
		
		C 				CX 				ECX 			RCX 
		
		D 				DX 				EDX 			RDX
		
		
		汇编代码
		__asm
		{
		
		}

- 数据类型

		
		数据类型的作用:编译器预算对象(变量)分配的内存空间大小
		
		基本类型
		
			字符 char
			
			整型 int  short long
			
			浮点型 实型  float double
		
		构造类型
		
			数组
			
			结构  struct
			
			联合  union
			
			枚举  enum
			
		指针类型	
		
			char * int * int **
		
		

- 变量

			
		变量 标识符:
			
			在程序运行过程中，其值可以改变
			
			变量在使用前必须先定义，定义变量前必须有相应的数据类型
		
		标识符命名规则:
		
				标识符不能是关键字
				
				标识符只能由字母、数字、下划线组成 
				
				第一个字符必须为字母或下划线
				
				标识符中字母区分大小写
				
		变量特点:
			
			变量在编译时为其分配相应的内存空间 
			
			可以通过其名字和地址访问相应内存
			
			
		声明和定义区别
			
			声明变量不需要建立存储空间，如:extern int a;
			
			//extern 关键字只做声明，不能做任何定义
			
			定义变量需要建立存储空间，如:int b;
			
			从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，
			所以并非所 有的声明都是定义:
				
				int b 它既是声明，同时又是定义
				
				对于 extern b 来讲它只是声明不是定义
			
			一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储
			
			空间的声明称之为“声明”。
		
		
			

- 常量
	
		
		常量特点:
		
			在程序运行过程中，其值不能被改变的量 
			
			常量一般出现在表达式或赋值语句中	
			
			命名一般都是大写
			
		常量定义:
			
			1 const 数据类型 常量名 = 常量值;
			
			2 #define 常量名 常量值 // 不在函数内部使用
				
				// 宏定义形式
		
		注意
		
			通过该define定义的常量 是根据值来匹配数据类型
			
			const 修饰常量是不安全的 可以通过指针来修改
			
		
			

- 进制

			
		当前的计算机系统使用的基本上是二进制系统
		
		数据在计算机中主要是以补码的形式存储的。	
			
		
		bit(比特)	一个二进制代表一位，一个位只能表示 0 或 1 两种状态。
					数据传 输是习惯以“位”(bit)为单位。
		
		Byte(字节)	一个字节为 8 个二进制，称为 8 位，计算机中存储的最小单位是字节。
					数据存储是习惯以“字节”(Byte)为单位。
					
		WORD(双字节) 2 个字节，16 位
		
		DWORD       两个 WORD，4 个字节，32 位
		
		1b			1bit，1 位
		
		1B			1Byte,1 字节，8 位
		
		1k，1K		1024
		
		1M(1 兆)	1024k, 1024*1024
		
		1G			1024M
		
		1T 1Kb(千位) 1024G
		
		C语言如何表示相应进制数：
			
			十进制		以正常数字 1-9 开头，如 123
			
			八进制		以数字 0 开头，如 0123
		
			十六进制 	以 0x 开头，如 0x123
			
			二进制 		C语言不能直接书写二进制数
		

- 计算机内存数值存储方式

		
		原码
		
		一个数的原码(原始的二进制码)有如下特点:
			
			最高位做为符号位，0 表示正,为 1 表示负
			
			其它数值部分就是数值本身绝对值的二进制数
			
			负数的原码是在其绝对值的基础上，最高位变为 1
			
		原码表示法简单易懂，与带符号数本身转换方便，只要符号还原即可，但当两
		
		个正数相减或不同符号数相加时，必须比较两个数哪个绝对值大，才能决定谁
		
		减谁，才能确定结果是正还是负，所以原码不便于加减运算。
		
		
		补码
			
			在计算机系统中，数值一律用补码来存储。
			
			模的概念：数学上7位数可以表示[0, 127]共128个值，超过128就会溢出，
			那么128就是7位数的模。
			
			而模一定的情况下，减法都可以变换成加法来运算，比如：
			
			你要把钟表往前拨2个小时，你可以把它往前拨10个小时来实现。
			
			这里-2就转化为了+10。 此时模是12
			
			下面看同余数的数学定义：
			
				如果a和b对于一个数m的余数相同，成a和b为m的同余数，
				
				或者称a和b互为补数，记做：
				
				a ≡ b (mod m)
				
				负数的余数如何定义？
				
				数学上是 x mod y = x - y * ( x / y )  y不等于0
				
				想算a-b的话（a，b都是正数），可以算成a+（-b的补数），比如：
				
				模为128的情况下，2-1=2+（-1）=2+（128-1）=128+1，由于溢出，结果是1 
		
			补码特点:
			
				对于正数，原码、反码、补码相同
				
				对于负数，其补码为它的反码加 1
				
				补码符号位不动，其他位求反，最后整个数加 1，得到原码
		
		在计算机系统中，数值一律用补码来存储，主要原因是: 
			
			统一了零的编码
			
			将符号位和其它位统一处理
			
			将减法运算转变为加法运算
			
			两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃
		
		
	
- sizeof 关键字

		
		sizeof 不是函数，所以不需要包含任何头文件
		
			它的功能是计算一个数据 类型的大小，单位为字节
			
			sizeof 的返回值为 size_t
			
			size_t 类型在 32 位操作系统下是 unsigned int，是一个无符号的整数
		
		

- 整型:int

			
		%d			输出一个有符号的 10 进制 int 类型	
		
		%u 			输出一个 10 进制的无符号数
			
		%o(字母 o)	输出 8 进制的 int 类型
		
		%x 输出 16 进制的 int 类型，字母以小写输出 
		
		%X 输出 16 进制的 int 类型，字母以大写写输出 	
			
	
- short、int、long、long long

		
		short(短整型)		2 字节
		
		int(整型)			4 字节
		
		
		long(长整形) Windows 为 4 字节，Linux 为 4 字节(32 位)，8 字节(64 位) 
		
		long long(长长整形) 8 字节
		
		
		注意:
			
			需要注意的是，整型数据在内存中占的字节数与所选择的操作系统有关。 
			虽然 C 语言标准中没有明确规定整型数据的长度，
			但 long 类型整数的长 度不能短于 int 类型， 
			short 类型整数的长度不能短于 int 类型。
			
			当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会 自动转化。
			但当一个大的类型赋值给一个小的数据类型，那么就可能丢失 高位。
		
		
		10				代表int 类型
		
		10l, 10L		代表long 类型
		
		0ll, 10LL       代表 long long 类型
			
		10u, 10U		代表 unsigned int 类型
			
		10ul, 10UL		代表 unsigned long 类型
		
		10ull, 10ULL	代表 unsigned long long 类型
		
		
		%hd				输出 short 类型
		
		%d				输出 int 类型
		
		%l 				输出 long 类型
		
		%ll 			输出 long long 类型
		
		%hu 			输出 unsigned short 类型
		
		%u 				输出 unsigned int 类型 
		
		%lu 			输出 unsigned long 类型
		
		%llu 			输出 unsigned long long 类型
		
		
	
- 有符号数和无符号数区别

		
		1) 有符号数
		有符号数是最高位为符号位，0 代表正数，1 代表负数
		
		2) 无符号数 无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。
		
		当我们写程序要处理一个不可能出现负值的时候，一般用无符号数，这样可以
		增大数的表达最大值
		
	
- 字符型:char

				
		字符变量的定义和输出
		字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，
		其中每个字符变量都会占用 1 个字节。
		在给字符型变量赋值时，需要用一对英文半角格 式的单引号(' ')把字符括起来。
				
		字符变量实际上并不是把该字符本身放到变量的内存单元中去，
		而是将该字符对应的 ASCII 编码放到变量的存储单元中。
		
		char 的本质就是一个 1 字节大小 的整型
		
		ASCII 码大致由以下两部分组成:
		
		ASCII 非打印控制字符: ASCII 表上的数字 0-31 分配给了控制字符，
		用于控制像打印机等一些外围设备。
		
		ASCII 打印字符:
		数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。
		
		数字 127 代表 Del 命令	
		
		\n 换行(LF) ，将当前位置移到下一行开头
		
		\r 回车(CR) ，将当前位置移到本行开头
				
	
- 数值溢出

			
		当超过一个数据类型能够存放最大的范围时，数值会溢出。
		有符号位最高位溢出的区别:符号位溢出会导致数的正负发生改变，但最高位
		的溢出会导致最高位丢失	
			
		char				1 字节		-128 到 127(-27 ~ 27-1)
		
		unsigned char		1 字节		0 到 255(0 ~ 28-1)
		

- 实型(浮点型):float、double

			
		float		4 字节		7 位有效数字
		
		double		8 字节		15~16 位有效数字	
		
		不以 f 结尾的常量是 double 类型，以 f 结尾的常量(如 3.14f)是 float 类型
		
			
			
	
- 类型限定符

			
		extern
			
			声明一个变量，extern 声明的变量没有建立存储空间。 
			
			extern int a;	
		
		const
			
			定义一个常量，常量的值不能修改。
			
			const int a = 10;	
			
		volatile 
		
			防止编译器优化代码	
		
		register
		
			定义寄存器变量，提高效率。register 是建议型的指令，
			而不是 register 命令型的指令，如果 CPU 有空闲寄存器，
			那么 register 就生效，如果没有空闲寄存器，那么 register 无效。
			

- 字符串格式化输出和输入

			
		字符串是内存中一段连续的 char 空间，以'\0'(数字 0)结尾
		
		字符串常量是由双引号括起来的字符序列，如“china”、“C
		
		program”，“$12.5”等都是合法的字符串常量	
			
		
		字符串常量与字符常量的不同：
		
			'a'          'a'
			
			"a"          'a''\0'
		
		每个字符串的结尾，编译器会自动的添加一个结束标志位'\0'，
		
		即 "a" 包含 两个字符'a'和’\0’
			
	
- printf 函数和 putchar 函数

		
		printf 是输出一个字符串，putchar 输出一个char
		
		printf 附加格式:
			
			l(字母 l)		附加在 d,u,x,o 前面，表示长整数
			
			-				左对齐
			
			m(代表一个整数) 	数据最小宽度
			
			0(数字 0)		将输出的前面补上 0 直到占满指定列宽为止不可以搭配使用
			
			m.n(代表一个整数) m 指域宽，即对应的输出项在输出设备上所占的字符数。n 指精
							度，用于说明输出的实型数的小数位数。对数值型的来说，未
							指定 n 时，隐含的精度为 n=6 位。

- scanf 函数与 getchar 函数

		
		getchar 是从标准输入设备读取一个 char。
		
		scanf 通过%转义的方式可以得到用户通过标准输入设备输入的数据。
		
		

- 比较运算符

		
		C 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。
		
		
		
		
		
	
- 类型转换

		
		数据有不同的类型，不同类型数据之间进行混合运算时必然涉及到类型的转换
		问题
		
		转换的方法有两种:
		
			自动转换(隐式转换):遵循一定的规则,由编译系统自动完成
		
			强制类型转换:把表达式的运算结果强制转换成所需的数据类型
		
		类型转换的原则:占用内存字节数少(值域小)的类型，
		
		向占用内存字节数多 (值域大)的类型转换，以保证精度不降低
		
		
		char short ---> signed int --->  unsigned int ---> long
		
		---> double <--- float
		
		
		强制转换
		
			强制类型转换指的是使用强制类型转换运算符，将一个变量或表达式转化成所需的类型
		
			其基本语法格式如下所示:
		    	
				(类型说明符) (表达式)
		
	
- 程序流程结构

			
		顺序结构、选择结构、循环结构	
			
		选择结构
				
			if
			
			if else
			
			if elseif elseif ... else
			
			三目运算符 ?:
			
			switch() {
				
				case val1 :
				
					break;
				
			}
			
		循环结构
		
			while() {
			}
			
			do{} while()
			
			for(){
			}
			
			

- 跳转语句 break、continue、goto

		
		break
			
			在 switch 条件语句和循环语句中都可以使用 break 语句	
			
			当它出现在switch条件语句中时，作用是终止某个 case并跳出switch结构
			
			当它出现在循环语句中，作用是跳出当前内循环语句，执行后面的代码
			
			当它出现在嵌套循环语句中，跳出最近的内循环语句，执行后面的代码
			
		continue
		
			在循环语句中，如果希望立即终止本次循环，并执行下一次循环，
			
			此时就需要 使用 continue 语句
		
		goto 语句(无条件跳转，尽量少用)
		
		
	
- 数组和字符串

		
		为了方便处理数据把具有相同类型的若干变量按有序形式组织
		起来称为 数组
		
		数组就是在内存中连续的相同类型的变量空间。同一个数组所有的成员都是相
		同的数据类型，同时所有的成员在内存中的地址是连续的
		
		int a[10];
		
		struct Stu boy[10];
		
		char s[10]; char *p[10];
		
	
-  一维数组的定义和使用

		
		方括号[]中常量表达式表示数组元素的个数
		
		下标从 0 开始计算
		
		
		
		

- 一维数组的初始化

		
		在定义数组的同时进行赋值，称为初始化。
		全局数组若不初始化，编译器将其
		初始化为零。局部数组若不初始化，内容为随机值
		
		int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
		//定义一个数组，同时初始化所有成员变量 
		
		int a[10] = { 1, 2, 3 };//初始化前三个成员，后面所有元素都设置为0
		
		int a[10] = { 0 };//所有的成员都设置为0
		
		//[]中不定义元素个数，定义时必须初始化
		
		int a[] = { 1, 2, 3, 4, 5 };//定义了一个数组，有5个成员
		
	
- 数组名

		
		数组名是一个地址的常量，代表数组中首元素的地址
		

- 二维数组

		
		二维数组定义的一般形式是:
			
			类型说明符 数组名[常量表达式 1][常量表达式 2]
			
		其中常量表达式 1 表示第一维下标的长度，常量表达式 2 表示第二维下标的长 度。
		
		int a[3][4];
		
		二维数组 a 是按行进行存放的，先存放 a[0]行，再存放 a[1]行、a[2]行，
		
		并 且每行有四个元素，也是依次存放的
		
	
- 二维数组的初始化

		
		int a[3][4] = {
			{ 1, 2, 3, 4 },
			{ 5, 6, 7, 8, },
			{ 9, 10, 11, 12 }
		};
		

- 字符数组与字符串
	
			
		字符数组与字符串
		
			C语言中没有字符串这种数据类型，可以通过 char 的数组来替代;
			
			字符串一定是一个 char 的数组，但 char 的数组未必是字符串;
			
			数字 0(和字符‘\0’等价)结尾的 char 数组就是一个字符串，
			
			但如果 char数组没有以数字 0 结尾，那么就不是一个字符串，
			
			只是普通字符数组，所以字符串是一种特殊的 char 的数组
			
	
- 字符串的初始化

		
		C语言没有字符串类型，通过字符数组模拟 
		
		C语言字符串，以字符‘\0’, 数字0
		
		//'\0'后面最好不要连着数字，有可能几个数字连起来刚好是一个转义字符
		
		/'\ddd'八进制字义字符，
		'\xdd'十六进制转移字符 
		// \012相当于\n
		char str[] = "\012abc";
		printf("str == %s\n", str);
		
	
- 字符串的输入输出

		
		由于字符串采用了'\0'标志
		char str[100];
		printf("input string1 : \n");
		scanf("%s", str);//scanf(“%s”,str)默认以空格分隔 
		printf("output:%s\n", str);
		
	
- 函数的调用

		
		当调用函数时，需要关心 5 要素:
			
			头文件:包含指定的头文件
			
			函数名字:函数名字必须和头文件声明的名字一样 
			
			功能:需要知道此函数能干嘛后才调用
			
			参数:参数类型要匹配
			
			返回值:根据需要接收返回值
		
		#include <time.h> time_t time(time_t *t);
		功能:获取当前系统时间
		参数:常设置为NULL
		返回值:当前系统时间, time_t 相当于long类型，单位为毫秒
		
		#include <stdlib.h>
		void srand(unsigned int seed);
		功能:用来设置rand()产生随机数时的随机种子 
		参数:如果每次seed相等，rand()产生随机数相等 返回值:无
		
		#include <stdlib.h> int rand(void);
		功能:返回一个随机数值 参数:无 返回值:随机数
		
		
	
- 字符串处理函数

		
		1. char *gets(char *s)
		
			从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾
			为止。
			
			s:字符串首地址
			
			gets(str)与 scanf(“%s”,str)的区别: 
				
				gets(str)允许输入的字符串含有空格 
				
				scanf(“%s”,str)不允许含有空格
				
			注意:由于 scanf()和 gets()无法知道字符串 s 大小，
			
			必须遇到换行符或读到 文件结尾为止才接收输入，
			因此容易导致字符数组越界(缓冲区溢出)的情况。
			
			scanf如何接受空格
			
				scanf("%[^\n]", str);
				scanf以空白字符为定界符，但如果输入的字符串是以其它字符为定界符的，
				那怎么办？[]就是专门处理这个问题的转换说明符。
				[]转换说明符可以通过两种方式产生结果字符集，
				如果第一个[字符右边没有抑扬符（^），
				那么处于[]之间的字符就是结果字符集，
				不在其中的可输入字符都作为定界符；
				如果左边[符号紧靠一个抑扬符（^），
				那么意义相反，^和]之间的字符是定界符，
				其余可输入字符是结果字符集。
		2 fgets()
		
		3 puts()
			
			标准设备输出s字符串，在输出完成后自动输出一个'\n'
			
		4 fputs()
		
			fputs()不会自动输出一个'\n'
			
		5 strlen()
		
		6 strcpy()
		
		7 strcat()
		
		8 strcat()
		
		9 strcmp()
		
			比较的是字符 ASCII 码大小
			
		10 strncmp()
		
		11 sprintf()
		
		12 sscanf()
		
		13 char *strchr(const char *s, int c);
			
			功能:在字符串s中查找字母c出现的位置
		14 strstr()
		
			在字符串haystack中查找字符串needle出现的位置
			
		15 strtok()
		
			
		16 atoi()
		
		17 atof()
		
		18 atol()
		
			

- 函数

		
		函数可分为系统函数和用户定义函数两种:
			
			系统函数，即库函数:	这是由编译系统提供的，用户不必自己定义这些函数
								可以直接使用它们，如printf()。
		
			用户定义函数:			用以解决用户的专门需要
		
		

- 形参列表
		
		在定义函数时指定的形参，在未出现函数调用时，它们并不占内存中的存储单元
		
		因此称它们是形式参数或虚拟参数，简称形参，表示它们并 不是实际存在的数据
		
		所以，形参里的变量不能赋值。
		
		如果没 有形参，圆括号内容为空，或写一个 void 关键字:
		
		
	
- 返回值

			
		函数的返回值是通过函数中的 return 语句获得的，return 后面的值也可
		以是一个表达式。
		
		a)尽量保证 return 语句中表达式的值和函数返回类型是同一类型	
		
		
		b)如果函数返回的类型和 return 语句中表达式的值不一致，则以函数返 回类型为准，
		
			即函数返回类型决定返回值的类型。对数值型数据，可以 自动进行类型转换
			
		注意:如果函数返回的类型和 return 语句中表达式的值不一致
		
		而它又无法自动进行类型转换，程序则会报错	
		
		c)return 语句的另一个作用为中断 return 所在的执行函数，
		
		类似于 break 中断循环、switch 语句一样
		
		
		d)如果函数带返回值，return 后面必须跟着一个值，如果函数没有返回值
		函数名字的前面必须写一个 void 关键字，这时候，我们写代码时也可以通过
		return 中断函数(也可以不用)，只是这时，return 后面不带内 容( 分号“;”除外)。
		
		void max()// 最好要有void关键字 
		{
			return; // 中断函数，这个可有可无 
		}
			
	
- void

		
		void 的字面意思是“空类型”，
		
		void *	则为“空类型指针”，
		
		void *	可以指向任何类型的数据
		
		void 真正发挥的作用在于：
			
			1 对函数返回的限定
			
			2 对函数参数的限定
		
		1、如果函数没有返回值，那么应声明为void 类型。在C语言中，
		
			凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。
		
			但是许多程序员却误以为其为void 类型。
		
			因此，为了避免混乱，我们在编写C程序时，
			
			对于任何函数都必须一个不漏地指定其类型。
		
			如果函数没有返回值，一定要声明为void 类型。
		
		2、如果函数无参数,那么应声明其参数为void
		
			所以，无论在C还是C++中，若函数不接受任何参数，
			
			一定要指明参数为void
		
		

- 函数返回值
	
		
		a)	如果函数定义没有返回值，函数调用时不能写 void 关键字，
			调用函数时也不能接收函数的返回值
			
		b)	如果函数定义有返回值，这个返回值我们根据用户需要可用可不用，
			
			但是，假如我们需要使用这个函数返回值，
			
			我们需要定义一个匹配类型的变量来接收
			

-  函数的声明

		
		如果使用用户自己定义的函数，而该函数与调用它的函数(即主调函数)不在
		同一文件中，或者函数定义的位置在主调函数之后，则必须在调用此函数之前
		对被调用的函数作声明。
		所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通
		知编译系统，相当于告诉编译器，函数在后面定义，以便使编译能正常进行。
		注意:一个函数只能被定义一次，但可以声明多次。
		
		函数定义和声明的区别:
			
			1)	定义是指对函数功能的确立，包括指定函数名、函数类型、形参及其类型、
				
				函数体等，
				
				它是一个完整的、独立的函数单位。 
		
			2)	声明的作用则是把函数的名字、函数类型以及形参的个数、
				
				类型和顺序(注意 不包括函数体)
			
				通知编译系统，以便在对包含函数调用的语句进行编译时，
				
				据此对其进行对照检查(例如函数名是否正确，实参与形参的类型和个数是否一致)。
		
	
- main 函数与 exit 函数

		
		在 main 函数中调用 exit 和 return 结果是一样的，
		
		但在子函数中调用 return 只是代表子函数终止了，
		
		在子函数中调用 exit，那么程序终止
		
		

- 多文件(分文件)编程

			
		把函数声明放在头文件 xxx.h 中，在主函数中包含相应头文件 
		
		在头文件对应的 xxx.c 中实现 xxx.h 声明的函数	
		
		防止头文件重复包含
		
		当一个项目比较大时，往往都是分文件，这时候有可能不小心把同一个头文件include多次，
		
		或者头文件嵌套包含
		
		为了避免同一个文件被 include 多次，C/C++中有两种方式，
		
			一种是 #ifndef 方式
		
			一种是 #pragma once 方式
		
		方法1
			
			#ifndef __SOMEFILE_H__ 
			#define __SOMEFILE_H__
			
				// 声明语句 
		
				#endif
				
		方法2
		
			#pragma once
			
			// 声明语句
			

	